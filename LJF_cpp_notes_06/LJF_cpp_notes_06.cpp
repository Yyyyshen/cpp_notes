// LJF_cpp_notes_06.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//设计模式和应用

using namespace std;

//
//设计模式
//

//
//经典设计模式书里有23种设计模式，根据目的可以划分为三大类
// 创建模式         如何创建对象
//  抽象工厂、生成器、工厂方法、原型、单件
// 结构型模式       如何组合对象
//  适配器、桥接、组成、代理、享元、外观、装饰
// 行为模式         如何处理对象之间的动态通信和职责分配
//  职责链、命令、解释器、迭代器、中介者、备忘录、策略、状态、观察者、模板方法、访问者
// 
// 描述体例
//  名称、别名、动机、结构、示例、效果、相关模式
// 
// 设计原则 SOLID
//  SRP，单一职责
//      不设计大而全的类，高内聚低耦合（string就是反例，又是字符串又是容器，接口复杂）
//  OCP，开闭
//      类封装的是否够好，是否不改变源码就能增加新功能
//  LSP，里氏替换
//      子类必须能够完全替代父类，不能改变、违反父类行为。支持泛型编程就尽量不要使用继承
//  ISP，接口隔离
//      尽量简化给外部调用的接口
//  DIP，依赖反转
//      上层避免依赖下层细节
// 
//DRY
// Don't repeate yourself
//KISS
// Keep it simple stupid
//
//基本含义宗旨大概都是保持代码简洁
//

//
//单例
// 双重检查锁比较麻烦，性能也不太高
// call_once可以代替
// 更好的办法是C++11的特性，函数内部static静态变量会保证线程安全
template<class T>
auto& instance() //生产单件对象的函数
{
	static T obj;
	return obj
}
//

//
//工厂
// 尽量避免重复代码，可以理解为对new的封装，用来生产对象
// 也形成了中间层，隔离了代码和创建对象，如果改变了对象类型，直接改工厂函数即可，不用大量重复修改
// 例如 make_unique、make_shared
//

//
//适配器
// 目的是接口转换，不需要修改源码，把一个对象转换成想要的形式
// array就是对C++原生数组的包装，是一个适配器
// 还有queue，stack也是
//

//
//外观模式
// 封装一组对象，简化这组对象的通信关系，提供一个高层次接口，让用户更容易使用
// async就是一个例子，封装了线程的创建，调度等细节
//

//
//代理模式
// 包装一个对象，但目的与适配不同，而是控制对象，不允许外部直接与内部对象通信
// 典型应用是智能指针
//

//
//职责链+命令
// 把多个对象串起来，每个对象都有机会处理请求，请求通常使用命令模式，解耦发送方和接收方
// C++的异常处理机制就是一个实际应用
//

//
//策略模式
// 封装不同算法，在外部非入侵的改变系统行为内核
// 容器和算法用到的比较、散列函数，for_each里的lambda表达式都可以算是应用
// 在if-else/switch-case分支决策的代码种，可以把每个分支逻辑都封装成类或者lambda表达式，再存进容器，让容器查找最合适的处理策略
// （同事的一个类种就是这样设计的，把各种命令处理分别封装成函数后将函数地址存放进了map，然后匹配处理）
//

//
//设计模式有人支持也有人不支持
//但思想上，大家都是想让代码更简洁易读，引入中间层，隔离，解耦，减少重复代码和变动。
//

int main()
{
	std::cout << "Hello World!\n";
}
